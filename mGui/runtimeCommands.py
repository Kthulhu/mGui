"""
runtimeCommands.py

Convenience methods for binding commands or callbacks to runtimeCommand objects.

"""

import maya.cmds as cmds
import inspect
import mGui.events as events
import json


def create_proxy_command(callable, *args, **kwargs):
    """
    generates an expression which imports a callable and executes it.

    Arguments may be passed through to the expression, but they must be built-in types

    """
    comment = "# autogenerated callback for %s" % callable.__module__ + '.' + callable.__name__
    source_mod = callable.__module__
    import_line = ''
    if source_mod != '__builtin__':
        import_line = "from %s import %s" % (source_mod, callable.__name__)

    # gymnastics to format the arguments and keywords if they exist
    arg_string = json.dumps(args)[1:-1]
    k = map(str, kwargs.keys())
    v = json.dumps(kwargs.values())[1:-1].split(", ")
    kwarg_string = ",".join([kk + "=" + vv for kk, vv in zip(k, v)])

    arguments = '%s%s%s' % (arg_string, (', ' if arg_string and kwarg_string else ''), kwarg_string)

    fn = "%s(%s)\n" % (callable.__name__, arguments)
    return "\n".join((comment, '', import_line, fn))


def create_runtime_command(name, func, category="mGui", annotation="", args= (), kwargs = {}):
    """
    creates a simple runTimeCommand which wraps the supplied function.  The function should be a no-argument callable
    which can be called using the pattern:

        from <module> import <fn>
        fn()

    For this reason, this is only appropriate for module-level functions.



    """

    assert callable(func), "function argument must be callable"

    if cmds.runTimeCommand(name, exists=True):
        cmds.runTimeCommand(name, e=True, delete=True)

    cb_string = create_proxy_command(func, *args, **kwargs)
    cmds.runTimeCommand(name, category=category, annotation=annotation, commandLanguage="python", command=cb_string)


class RuntimeEvent(object):
    """
    Exposes a set of class methods for attaching mGui events to runTimeCommands.

    Typical usage:

        import mGui.runtimeCommands as rc
        def example(*args, **kwargs):
            print 'example:', args, kwargs

        rc.RuntimeEvent.create_command("sampleRuntimeCommand", example)

    This will create an event object in named 'sampleRuntimeCommand_event', add the example function to it as a
    handler, and make a new runTimeCommand which looks like:

        from mGui.runtimeCommands import fire_callback
        fire_callback("sampleRuntimeCommand_event")

    This runTimeCommand can be bound to a hotkey or invoked from MEL.

    @note: Don't instantiate this class, it's just a 'namespace' class with a set of related methods.
    """
    REGISTRY = {}

    @classmethod
    def create(cls, name):
        """
        Creates an mGui.events.Event object with the supplied name. If the named Event already exists, return it.
        :param name: string name of the new Event
        :return: mGui.events.Event object
        """
        if not name in cls.REGISTRY:
            cls.REGISTRY[name] = events.Event()
        return cls.REGISTRY[name]

    @classmethod
    def find(cls, name):
        """
        Return the named callback Event, if it exists.  If not, return None
        :param name: name of the Event object to return
        :return: the named Event object, or None if there is no object with that name
        """
        return cls.REGISTRY.get(name)

    @classmethod
    def add_handler(cls, name, handler):
        """
        Add the supplied callable object to the named event as a handler
        @see events.Event for how handlers work
        :param name: name of the Event object
        :param handler: callable handler function or class
        """
        cb = cls.find(name)
        cb += handler

    @classmethod
    def remove_handler(cls, name, handler):
        """
        Remove supplied callable object from the named event
        @see events.Event for how handlers work
        :param name: name of the Event object
        :param handler: callable handler function or class
        """
        cb = cls.find(name)
        cb -= handler


    @classmethod
    def create_command(cls, name, func, category="undeadlabs", annotation=""):
        """
        Creates a new runtimeCommand (or replaces an existing one) which fires an mGui.event.Event when invoked.

        Note that the Event object will not automatically be recreated on maya startup. The recommended use
        is to invoke this command when Maya starts up an bind the hotkey to a new event; this will replace the
        existing runTimeCommand with a new identical one but also create and bind the runtime event.  Alternatively
        you could create a named event at startup time using RuntimeEvent.create()



        :param name:        name of the new runtime command
        :param func:        (optional) callable function to be used as a handler for the new event
        :param category:    display category for the new runTimeCommand (defaults to 'mGui')
        :param annotation:  descriptive text for the new runTimeCommand
        :return: The event object for this command
        """
        new_event = cls.create(name + "_event")
        if func and callable(func):
            new_event += func

        create_runtime_command(name, fire_callback, category, annotation, args=(name + "_event",))
        return new_event


def fire_callback(name, *args, **kwargs):
    """
    Fire the runtimeEvent associated with <name>

    Print a warning if the event does not exist
    """
    rc = RuntimeEvent.find(name)
    if rc:
        rc(*args, **kwargs)
    else:
        cmds.warning("no RuntimeEvent named %s. Create one using RuntimeEvent.create" % name)
